#!/usr/bin/env bash
set -euo pipefail

ROOT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"
SECURITY_DIR="${ROOT_DIR}/security"
CHECKSUM_FILE="${SECURITY_DIR}/dependency-checksums.properties"
KEYS_FILE="${SECURITY_DIR}/pgp-trusted-keys.list"
REPO_BASE="https://repo1.maven.org/maven2"
MVN_CMD="mvn"
LOCAL_REPO="${LOCAL_REPO:-${HOME}/.m2/repository}"

# Ensure required tooling is present
for tool in curl gpg openssl "${MVN_CMD}"; do
  if ! command -v "${tool}" >/dev/null 2>&1; then
    echo "Required tool '${tool}' not found on PATH" >&2
    exit 1
  fi
done

MODE="update"
if [[ $# -gt 0 ]]; then
  case "$1" in
    --update) MODE="update" ;;
    --verify) MODE="verify" ;;
    *)
      echo "Usage: $0 [--update|--verify]" >&2
      exit 2
      ;;
  esac
fi

declare -a DEP_COORDS=(
  "org.slf4j:slf4j-api:slf4j.version"
  "com.google.auto.service:auto-service:auto-service.version"
  "com.google.auto:auto-common:auto-common.version"
  "com.google.auto.service:auto-service-annotations:auto-service.version"
  "org.openjdk.jmh:jmh-core:jmh.version"
  "org.openjdk.jmh:jmh-generator-annprocess:jmh.version"
  "ch.qos.logback:logback-classic:logback.version"
  "com.google.guava:guava:google.guava.version"
  "com.google.guava:listenablefuture:google.guava-listenablefuture.version"
  "com.google.guava:failureaccess:google.guava-failureaccess.version"
  "com.google.errorprone:error_prone_annotations:google.errorprone-annotations.version"
  "com.google.j2objc:j2objc-annotations:google.j2objc-annotations.version"
  "org.checkerframework:checker-qual:checkerframework.checker-qual.version"
)

declare -A SPECIAL_KEY_FLAGS=(
  ["com.google.guava:failureaccess"]="noKey"
  ["com.google.j2objc:j2objc-annotations"]="noKey"
)

tmp_checks="$(mktemp)"
tmp_keys="$(mktemp)"
cleanup() {
  rm -f "${tmp_checks}" "${tmp_keys}"
}
trap cleanup EXIT

printf '' > "${tmp_checks}"
{
  echo "# Trusted PGP fingerprints for dependency verification"
  echo "# Generated by scripts/update-dependency-security.sh"
  echo
} > "${tmp_keys}"

resolve_version() {
  "${MVN_CMD}" -q -DforceStdout -Dexpression="$1" help:evaluate
}

for entry in "${DEP_COORDS[@]}"; do
  IFS=':' read -r group artifact property <<<"${entry}"
  version="$(resolve_version "${property}")"

  if [[ -z "${version}" || "${version}" == *"null object"* ]]; then
    echo "Failed to resolve version for property '${property}'" >&2
    exit 1
  fi

  group_path="${group//./\/}"
  jar="${artifact}-${version}.jar"
  jar_path="${LOCAL_REPO}/${group_path}/${artifact}/${version}/${jar}"
  jar_url="${REPO_BASE}/${group_path}/${artifact}/${version}/${jar}"
  sig_url="${jar_url}.asc"

  if [[ ! -f "${jar_path}" ]]; then
    if ! "${MVN_CMD}" -q dependency:get -Dartifact="${group}:${artifact}:${version}" -Dtransitive=false >/dev/null; then
      echo "Failed to resolve ${group}:${artifact}:${version} to local repository" >&2
      exit 1
    fi
  fi

  if [[ ! -f "${jar_path}" ]]; then
    echo "Jar ${jar_path} still not found after resolution." >&2
    exit 1
  fi

  sig_path="${jar_path}.asc"
  sig_tmp="$(mktemp)"
  if [[ -f "${sig_path}" ]]; then
    cp "${sig_path}" "${sig_tmp}"
  else
    if ! curl -sSfL "${sig_url}" -o "${sig_tmp}"; then
      echo "Failed to download signature ${sig_url}" >&2
      exit 1
    fi
    cp "${sig_tmp}" "${sig_path}"
  fi

  sha256="$(openssl dgst -sha256 "${jar_path}" | awk '{print $2}')"
  if [[ -z "${sha256}" ]]; then
    echo "Failed to compute SHA-256 for ${jar}" >&2
    exit 1
  fi
  echo "${group}:${artifact}:${version}=${sha256}" >> "${tmp_checks}"

  fingerprint="$(gpg --list-packets "${sig_tmp}" 2>/dev/null | awk '/issuer fpr/ {print $NF; exit}')"
  fingerprint="${fingerprint//[\(\)]/}"
  if [[ -z "${fingerprint}" ]]; then
    echo "Unable to extract fingerprint from ${sig_url}" >&2
    exit 1
  fi

  key_entry="0x${fingerprint}"
  special_flag="${SPECIAL_KEY_FLAGS["${group}:${artifact}"]:-}"
  if [[ -n "${special_flag}" ]]; then
    key_entry="${key_entry}, ${special_flag}"
  fi
  printf "%s:%s = %s\n" "${group}" "${artifact}" "${key_entry}" >> "${tmp_keys}"

  rm -f "${sig_tmp}"
done

mkdir -p "${SECURITY_DIR}"
if [[ "${MODE}" == "verify" ]]; then
  if [[ ! -f "${CHECKSUM_FILE}" || ! -f "${KEYS_FILE}" ]]; then
    echo "Cannot verify because ${CHECKSUM_FILE} or ${KEYS_FILE} is missing." >&2
    exit 1
  fi
  if ! cmp -s "${tmp_checks}" "${CHECKSUM_FILE}"; then
    echo "Checksum file ${CHECKSUM_FILE} is out of date." >&2
    exit 1
  fi
  if ! cmp -s "${tmp_keys}" "${KEYS_FILE}"; then
    echo "PGP key file ${KEYS_FILE} is out of date." >&2
    exit 1
  fi
  echo "Dependency checksums and PGP keys verified."
else
  mv "${tmp_checks}" "${CHECKSUM_FILE}"
  mv "${tmp_keys}" "${KEYS_FILE}"
  echo "Updated ${CHECKSUM_FILE} and ${KEYS_FILE}"
fi
